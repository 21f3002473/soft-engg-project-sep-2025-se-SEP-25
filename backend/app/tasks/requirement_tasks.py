import logging
from datetime import datetime
from app.celery_app import celery_app
from app.database import get_session
from app.core.agents.pm_agents.pm_requirements_agent import get_pm_requirements_agent
from app.core.agents.pm_agents.pm_roadmap_agent import get_pm_roadmap_agent
from app.core.agents.pm_agents.pm_email_agent import get_pm_email_agent
from app.core.agents.pm_agents.pm_daily_report_agent import PMDailyReportAgent
from app.core.agents.pm_agents.employee_report_agent import EmployeePerformanceAgent
from app.tasks.email_tasks import send_email_task

logger = logging.getLogger(__name__)


@celery_app.task(bind=True, max_retries=2)
def analyze_project_requirements_ai(
    self, project_id: int, new_requirement_id: int = None, notify_email: str = None
):
    """
    Analyze project requirements using AI agent and generate execution report.

    Args:
        project_id: Project ID to analyze
        new_requirement_id: ID of newly added requirement
        notify_email: Email address to send report to
    """
    try:
        logger.info(f"Starting AI analysis for project {project_id}")

        session = next(get_session())

        agent = get_pm_requirements_agent(session)

        report = agent.analyze(project_id, new_requirement_id)

        if "error" in report:
            logger.error(f"AI Analysis failed: {report['error']}")

            raise self.retry(
                exc=Exception(report["error"]), countdown=60 * (2**self.request.retries)
            )

        if notify_email:
            send_requirement_report_email.delay(report, notify_email)

        logger.info(f"AI Analysis completed successfully for project {project_id}")
        return {"status": "success", "report": report}

    except Exception as e:
        logger.error(f"Error in AI requirement analysis task: {str(e)}", exc_info=True)
        if self.request.retries < self.max_retries:
            raise self.retry(exc=e, countdown=60 * (2**self.request.retries))
        return {"status": "error", "message": str(e)}


@celery_app.task
def send_requirement_report_email(report: dict, email: str):
    """
    Send AI-generated requirement analysis report via email.

    Args:
        report: AI-generated analysis report dictionary
        email: Recipient email address
    """
    try:
        project_name = report.get("project", {}).get("project_name", "Unknown Project")

        subject = f"ü§ñ AI-Powered Project Analysis: {project_name}"

        body = _generate_text_report(report)

        html_body = _generate_html_report(report)

        return send_email_task.delay(email, subject, body, html_body)

    except Exception as e:
        logger.error(f"Error sending AI requirement report: {str(e)}", exc_info=True)
        return {"status": "error", "message": str(e)}


def _generate_text_report(report: dict) -> str:
    """Generate plain text AI report."""
    project = report.get("project", {})
    summary = report.get("summary", {})
    recommendations = report.get("recommendations", [])

    text = f"""
ü§ñ AI-POWERED PROJECT REQUIREMENTS ANALYSIS
==========================================

Project: {project.get('project_name', 'Unknown')}
Project ID: {project.get('project_id', 'Unknown')}
Client: {project.get('client_name', 'Unknown')}
Status: {project.get('status', 'Unknown')}
Analysis Date: {report.get('analysis_date', 'Unknown')}
Generated by: {report.get('generated_by', 'AI Agent')}

SUMMARY
-------
Total Requirements: {summary.get('total_requirements', 0)}
‚úÖ Completed: {summary.get('completed', 0)}
üîÑ In Progress: {summary.get('in_progress', 0)}
‚è≥ Pending: {summary.get('pending', 0)}
üìä Completion Rate: {summary.get('completion_rate', 0)}%

AI ANALYSIS
-----------
{summary.get('ai_analysis', 'No analysis available')}

"""

    if report.get("new_requirement"):
        text += f"""
üÜï NEW REQUIREMENT ADDED
-----------------------
ID: {report['new_requirement'].get('requirement_id', 'Unknown')}
Description: {report['new_requirement'].get('description', 'No description')}

"""

    text += """
üéØ EXECUTION PLAN
-----------------
"""

    for phase in report.get("execution_plan", []):
        text += f"""
{phase.get('phase', 'Unknown Phase')} - Priority: {phase.get('priority', 'UNKNOWN')}
{phase.get('rationale', 'N/A')}
Requirements: {len(phase.get('requirements', []))}
"""

    if report.get("execution_plan_narrative"):
        text += f"""

AI EXECUTION INSIGHTS
--------------------
{report.get('execution_plan_narrative', '')}
"""

    text += """

üí° AI RECOMMENDATIONS
--------------------
"""
    for i, rec in enumerate(recommendations, 1):
        text += f"{i}. {rec}\n"

    text += """

---
This report was generated by an AI Agent using LangGraph and Groq AI.
The insights are based on current project data and best practices.
"""

    return text


def _generate_html_report(report: dict) -> str:
    """Generate beautiful HTML AI report."""
    project = report.get("project", {})
    summary = report.get("summary", {})
    recommendations = report.get("recommendations", [])

    completion_rate = summary.get("completion_rate", 0)
    if completion_rate >= 70:
        status_color = "#28a745"
        status_emoji = "üü¢"
    elif completion_rate >= 40:
        status_color = "#ffc107"
        status_emoji = "üü°"
    else:
        status_color = "#dc3545"
        status_emoji = "üî¥"

    html = f"""
    <html>
        <head>
            <style>
                body {{ font-family: 'Segoe UI', Arial, sans-serif; line-height: 1.6; color: #333; background-color: #f5f5f5; }}
                .container {{ max-width: 900px; margin: 0 auto; padding: 20px; background-color: white; }}
                .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; margin-bottom: 20px; }}
                .header h1 {{ margin: 0; font-size: 28px; }}
                .header .subtitle {{ opacity: 0.9; margin-top: 10px; }}
                .ai-badge {{ display: inline-block; background-color: rgba(255,255,255,0.2); padding: 5px 15px; border-radius: 20px; font-size: 12px; margin-top: 10px; }}
                .section {{ margin: 20px 0; padding: 20px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
                .section h2 {{ color: #667eea; margin-top: 0; border-bottom: 2px solid #667eea; padding-bottom: 10px; }}
                .summary-grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }}
                .stat-box {{ padding: 20px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); border-radius: 8px; text-align: center; }}
                .stat-number {{ font-size: 32px; font-weight: bold; color: {status_color}; }}
                .stat-label {{ font-size: 13px; color: #666; margin-top: 5px; }}
                .ai-analysis {{ padding: 20px; background-color: #f8f9fa; border-left: 4px solid #667eea; border-radius: 4px; margin: 15px 0; white-space: pre-wrap; }}
                .phase {{ margin: 15px 0; padding: 15px; border-radius: 8px; background-color: white; border: 2px solid #e0e0e0; }}
                .phase h3 {{ margin-top: 0; color: #764ba2; }}
                .priority-high {{ border-left: 4px solid #dc3545; background-color: #fff5f5; }}
                .priority-medium {{ border-left: 4px solid #ffc107; background-color: #fffef5; }}
                .priority-low {{ border-left: 4px solid #28a745; background-color: #f5fff5; }}
                .recommendation {{ padding: 15px; margin: 10px 0; background: linear-gradient(to right, #e7f3ff, #ffffff); border-left: 4px solid #2196F3; border-radius: 4px; }}
                .new-req {{ padding: 15px; background: linear-gradient(to right, #d4edda, #ffffff); border: 2px solid #28a745; border-radius: 8px; margin: 15px 0; }}
                .footer {{ margin-top: 30px; padding: 20px; border-top: 2px solid #e0e0e0; text-align: center; color: #666; font-size: 13px; }}
                .completion-badge {{ font-size: 48px; font-weight: bold; color: {status_color}; text-align: center; margin: 20px 0; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>ü§ñ AI-Powered Requirements Analysis</h1>
                    <div class="subtitle">
                        <strong>Project:</strong> {project.get('project_name', 'Unknown')}<br>
                        <strong>Client:</strong> {project.get('client_name', 'Unknown')}<br>
                        <strong>Status:</strong> {project.get('status', 'Unknown')}
                    </div>
                    <div class="ai-badge">Powered by Groq AI + LangGraph</div>
                </div>
                
                <div class="section">
                    <h2>üìä Project Overview</h2>
                    <div class="summary-grid">
                        <div class="stat-box">
                            <div class="stat-number">{summary.get('total_requirements', 0)}</div>
                            <div class="stat-label">Total Requirements</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" style="color: #ffc107;">‚è≥ {summary.get('pending', 0)}</div>
                            <div class="stat-label">Pending</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" style="color: #2196F3;">üîÑ {summary.get('in_progress', 0)}</div>
                            <div class="stat-label">In Progress</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" style="color: #28a745;">‚úÖ {summary.get('completed', 0)}</div>
                            <div class="stat-label">Completed</div>
                        </div>
                    </div>
                    <div class="completion-badge">
                        {status_emoji} {summary.get('completion_rate', 0)}%
                        <div style="font-size: 16px; color: #666; margin-top: 5px;">Completion Rate</div>
                    </div>
                </div>
    """

    if summary.get("ai_analysis"):
        html += f"""
                <div class="section">
                    <h2>üß† AI Analysis</h2>
                    <div class="ai-analysis">{summary.get('ai_analysis', 'No analysis available')}</div>
                </div>
        """

    if report.get("new_requirement"):
        html += f"""
                <div class="new-req">
                    <h3 style="margin-top: 0; color: #28a745;">üÜï New Requirement Added</h3>
                    <p><strong>ID:</strong> {report['new_requirement'].get('requirement_id', 'Unknown')}</p>
                    <p><strong>Description:</strong> {report['new_requirement'].get('description', 'No description')}</p>
                </div>
        """

    html += """
                <div class="section">
                    <h2>üéØ AI-Generated Execution Plan</h2>
    """

    for phase in report.get("execution_plan", []):
        priority_class = f"priority-{phase.get('priority', 'medium').lower()}"
        html += f"""
                    <div class="phase {priority_class}">
                        <h3>{phase.get('phase', 'Unknown Phase')}</h3>
                        <p><strong>Priority:</strong> <span style="color: {status_color};">{phase.get('priority', 'UNKNOWN')}</span></p>
                        <p><strong>Rationale:</strong> {phase.get('rationale', 'N/A')}</p>
                        <p><strong>Requirements:</strong> {len(phase.get('requirements', []))}</p>
                    </div>
        """

    if report.get("execution_plan_narrative"):
        html += f"""
                    <div class="ai-analysis" style="margin-top: 20px;">
                        <h4 style="margin-top: 0;">üí≠ AI Execution Insights</h4>
                        {report.get('execution_plan_narrative', '')}
                    </div>
        """

    html += """
                </div>
                
                <div class="section">
                    <h2>üí° AI Recommendations</h2>
    """

    for rec in recommendations:
        html += f"""
                    <div class="recommendation">{rec}</div>
        """

    html += f"""
                </div>
                
                <div class="footer">
                    <p><strong>Generated by:</strong> {report.get('generated_by', 'AI Agent')}</p>
                    <p><strong>Model:</strong> {report.get('model', 'Unknown')}</p>
                    <p><strong>Analysis Date:</strong> {report.get('analysis_date', 'Unknown')}</p>
                    <p style="margin-top: 15px;">This report was generated using advanced AI techniques including LangGraph workflows and Groq AI.</p>
                    <p>The insights provided are based on current project data and industry best practices.</p>
                </div>
            </div>
        </body>
    </html>
    """

    return html


@celery_app.task(bind=True, max_retries=2)
def generate_project_roadmap_task(
    self,
    project_id: int,
    client_id: int,
    trigger_type: str = "manual",
    notify_email: str = None,
):
    """
    Generate project roadmap using AI agent and optionally send email notification.

    Args:
        project_id: Project ID
        client_id: Client ID
        trigger_type: What triggered the generation (manual, requirement_added, etc.)
        notify_email: Email address to send roadmap to
    """
    try:
        logger.info(
            f"Starting roadmap generation for project {project_id}, client {client_id}"
        )

        session = next(get_session())

        agent = get_pm_roadmap_agent(session)

        roadmap = agent.generate_roadmap(project_id)

        if "error" in roadmap:
            logger.error(f"Roadmap generation failed: {roadmap['error']}")
            raise self.retry(
                exc=Exception(roadmap["error"]),
                countdown=60 * (2**self.request.retries),
            )

        saved_roadmap = agent.save_roadmap(
            roadmap=roadmap, client_id=client_id, trigger_type=trigger_type
        )

        if notify_email:
            send_roadmap_email.delay(roadmap, notify_email)

        logger.info(
            f"Roadmap generation completed successfully for project {project_id}"
        )
        return {"status": "success", "roadmap": roadmap, "roadmap_id": saved_roadmap.id}

    except Exception as e:
        logger.error(f"Error in roadmap generation task: {str(e)}", exc_info=True)
        if self.request.retries < self.max_retries:
            raise self.retry(exc=e, countdown=60 * (2**self.request.retries))
        return {"status": "error", "message": str(e)}


@celery_app.task
def send_roadmap_email(roadmap: dict, email: str):
    """
    Send project roadmap via email.

    Args:
        roadmap: Project roadmap dictionary
        email: Recipient email address
    """
    try:
        project_name = roadmap.get("project", {}).get("project_name", "Unknown Project")

        subject = f"üìã Project Roadmap: {project_name}"

        body = _generate_roadmap_text(roadmap)

        html_body = _generate_roadmap_html(roadmap)

        return send_email_task.delay(email, subject, body, html_body)

    except Exception as e:
        logger.error(f"Error sending roadmap email: {str(e)}", exc_info=True)
        return {"status": "error", "message": str(e)}


def _generate_roadmap_text(roadmap: dict) -> str:
    """Generate plain text roadmap report."""
    project = roadmap.get("project", {})
    summary = roadmap.get("summary", "")
    milestones = roadmap.get("milestones", [])
    timeline = roadmap.get("timeline", {})

    text = f"""
üìã PROJECT ROADMAP
==================

Project: {project.get('project_name', 'Unknown')}
Project ID: {project.get('project_id', 'Unknown')}
Status: {project.get('status', 'Unknown')}
Client: {roadmap.get('client', {}).get('client_name', 'Unknown')}
Generated: {roadmap.get('generated_at', 'Unknown')}

SUMMARY
-------
{summary}

TIMELINE
--------
Estimated Completion: {timeline.get('total_estimated_days', 0)} days
Start Date: {timeline.get('start_date', 'N/A')}
End Date: {timeline.get('estimated_completion_date', 'N/A')}

MILESTONES
----------
"""

    for i, milestone in enumerate(milestones, 1):
        text += f"""
{i}. {milestone.get('name', 'Unknown Milestone')}
   Status: {milestone.get('status', 'PENDING')}
   Requirements: {len(milestone.get('requirements', []))}
   Duration: {milestone.get('estimated_duration_days', 0)} days
   Description: {milestone.get('description', 'No description')}
"""

    recommendations = roadmap.get("recommendations", [])
    if recommendations:
        text += "\nRECOMMENDATIONS\n---------------\n"
        for i, rec in enumerate(recommendations, 1):
            text += f"{i}. {rec}\n"

    text += """

---
This roadmap was generated automatically using AI analysis.
"""

    return text


def _generate_roadmap_html(roadmap: dict) -> str:
    """Generate HTML roadmap report."""
    project = roadmap.get("project", {})
    client = roadmap.get("client", {})
    summary = roadmap.get("summary", "")
    milestones = roadmap.get("milestones", [])
    timeline = roadmap.get("timeline", {})
    categorized = roadmap.get("categorized_requirements", {})

    html = f"""
    <html>
        <head>
            <style>
                body {{ font-family: 'Segoe UI', Arial, sans-serif; line-height: 1.6; color: #333; }}
                .container {{ max-width: 900px; margin: 0 auto; padding: 20px; background-color: white; }}
                .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px; margin-bottom: 20px; }}
                .section {{ margin: 20px 0; padding: 20px; background-color: #f8f9fa; border-radius: 8px; }}
                .milestone {{ margin: 15px 0; padding: 20px; border-left: 5px solid #667eea; background-color: white; border-radius: 5px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
                .milestone h3 {{ margin-top: 0; color: #667eea; }}
                .status-badge {{ display: inline-block; padding: 5px 15px; border-radius: 20px; font-size: 12px; font-weight: bold; }}
                .status-completed {{ background-color: #d4edda; color: #155724; }}
                .status-in-progress {{ background-color: #cce5ff; color: #004085; }}
                .status-pending {{ background-color: #fff3cd; color: #856404; }}
                .stats {{ display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0; }}
                .stat-box {{ padding: 15px; background: white; border-radius: 8px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
                .stat-number {{ font-size: 32px; font-weight: bold; color: #667eea; }}
                .stat-label {{ font-size: 14px; color: #666; }}
                .recommendation {{ padding: 15px; margin: 10px 0; background: linear-gradient(to right, #e7f3ff, #ffffff); border-left: 4px solid #2196F3; border-radius: 4px; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>üìã Project Roadmap</h1>
                    <p><strong>Project:</strong> {project.get('project_name', 'Unknown')}</p>
                    <p><strong>Project ID:</strong> {project.get('project_id', 'N/A')}</p>
                    <p><strong>Client:</strong> {client.get('client_name', 'Unknown')}</p>
                    <p><strong>Status:</strong> {project.get('status', 'Unknown')}</p>
                </div>
                
                <div class="section">
                    <h2>üìä Project Overview</h2>
                    <div class="stats">
                        <div class="stat-box">
                            <div class="stat-number">{roadmap.get('total_requirements', 0)}</div>
                            <div class="stat-label">Total Requirements</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" style="color: #28a745;">{roadmap.get('completed_count', 0)}</div>
                            <div class="stat-label">Completed</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-number" style="color: #ffc107;">{roadmap.get('pending_count', 0)}</div>
                            <div class="stat-label">Pending</div>
                        </div>
                    </div>
                    <p><strong>Summary:</strong> {summary}</p>
                </div>
                
                <div class="section">
                    <h2>‚è±Ô∏è Timeline</h2>
                    <p><strong>Estimated Completion:</strong> {timeline.get('total_estimated_days', 0)} days</p>
                    <p><strong>Target Date:</strong> {timeline.get('estimated_completion_date', 'N/A')[:10]}</p>
                </div>
                
                <div class="section">
                    <h2>üéØ Milestones</h2>
    """

    for i, milestone in enumerate(milestones, 1):
        status = milestone.get("status", "PENDING").lower().replace("_", "-")
        status_class = f"status-{status}"

        html += f"""
                    <div class="milestone">
                        <h3>{i}. {milestone.get('name', 'Unknown Milestone')}</h3>
                        <p><span class="status-badge {status_class}">{milestone.get('status', 'PENDING')}</span></p>
                        <p><strong>Requirements:</strong> {len(milestone.get('requirements', []))}</p>
                        <p><strong>Duration:</strong> {milestone.get('estimated_duration_days', 0)} days</p>
                        <p><strong>Description:</strong> {milestone.get('description', 'Complete assigned requirements')}</p>
                        
                        <details style="margin-top: 10px;">
                            <summary style="cursor: pointer; color: #667eea;">View Requirements ({len(milestone.get('requirements', []))})</summary>
                            <ul style="margin-top: 10px;">
        """

        for req in milestone.get("requirements", []):
            html += f"""
                                <li>
                                    <strong>{req.get('requirement_id', 'N/A')}</strong>: {req.get('description', 'No description')}
                                    <br><small>Status: {req.get('status', 'N/A')} | Complexity: {req.get('complexity', 'N/A')}</small>
                                </li>
            """

        html += """
                            </ul>
                        </details>
                    </div>
        """

    recommendations = roadmap.get("recommendations", [])
    if recommendations:
        html += """
                </div>
                
                <div class="section">
                    <h2>üí° Recommendations</h2>
        """

        for rec in recommendations:
            html += f"""
                    <div class="recommendation">{rec}</div>
            """

    html += f"""
                </div>
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e0e0e0; text-align: center; color: #666; font-size: 13px;">
                    <p><strong>Generated:</strong> {roadmap.get('generated_at', 'N/A')}</p>
                    <p>This roadmap was generated automatically using AI analysis.</p>
                    <p>For questions or updates, contact your project manager.</p>
                </div>
            </div>
        </body>
    </html>
    """

    return html


@celery_app.task(bind=True, max_retries=2)
def generate_progress_email_task(
    self,
    project_id: int,
    client_id: int,
    trigger_type: str = "manual",
    auto_send: bool = True,
):
    """
    Generate and send client progress email using AI agent.

    Args:
        project_id: Project ID
        client_id: Client ID
        trigger_type: What triggered the email (manual, update_added, milestone_completed, etc.)
        auto_send: Whether to automatically send the email after generation
    """
    try:
        logger.info(
            f"Starting progress email generation for project {project_id}, client {client_id}"
        )

        session = next(get_session())

        agent = get_pm_email_agent(session)

        email_result = agent.generate_email(project_id, client_id, trigger_type)

        if "error" in email_result:
            logger.error(f"Email generation failed: {email_result['error']}")
            raise self.retry(
                exc=Exception(email_result["error"]),
                countdown=60 * (2**self.request.retries),
            )

        if auto_send:
            recipient_email = email_result.get("client", {}).get("email")
            if recipient_email:
                send_email_task.delay(
                    recipient_email,
                    email_result["subject"],
                    email_result["body_text"],
                    email_result["body_html"],
                )
                logger.info(f"Progress email sent to {recipient_email}")

        logger.info(f"Progress email generation completed for project {project_id}")
        return {"status": "success", "email": email_result}

    except Exception as e:
        logger.error(
            f"Error in progress email generation task: {str(e)}", exc_info=True
        )
        if self.request.retries < self.max_retries:
            raise self.retry(exc=e, countdown=60 * (2**self.request.retries))
        return {"status": "error", "message": str(e)}


@celery_app.task(bind=True, max_retries=2)
def generate_daily_project_report(
    self,
    project_id: int,
    client_id: int,
    auto_send: bool = True,
    report_date: str = None,
):
    """
    Generate daily project progress report using AI agent.
    This task should be scheduled to run daily for active projects.

    Args:
        project_id: Project ID
        client_id: Client ID
        auto_send: Whether to send report via email
        report_date: Date for the report (defaults to today)
    """
    from app.database.product_manager_models import ProjectDailyReport, Client
    from sqlmodel import select

    try:
        logger.info(f"Starting daily report generation for project {project_id}")

        session = next(get_session())

        if not report_date:
            report_date = datetime.now().strftime("%Y-%m-%d")

        agent = PMDailyReportAgent(session)

        report_result = agent.generate_daily_report(
            project_id=project_id, client_id=client_id, report_date=report_date
        )

        if not report_result.get("success"):
            error_msg = report_result.get("error", "Unknown error")
            logger.error(f"Daily report generation failed: {error_msg}")
            raise self.retry(
                exc=Exception(error_msg), countdown=60 * (2**self.request.retries)
            )

        daily_report = ProjectDailyReport(
            project_id=project_id,
            client_id=client_id,
            report_date=datetime.now(),
            generated_at=datetime.now(),
            trigger_type="scheduled",
            summary=report_result["summary"],
            achievements=str(report_result["achievements"]),
            blockers=str(report_result["blockers"]),
            upcoming_tasks=str(report_result["upcoming_tasks"]),
            metrics=str(report_result["metrics"]),
            report_body_text=report_result["report_body_text"],
            report_body_html=report_result["report_body_html"],
            updates_count=report_result.get("updates_count", 0),
            completion_percentage=report_result["metrics"].get("overall_completion", 0),
            update_ids_included=",".join(map(str, report_result.get("update_ids", []))),
            project_status_snapshot=report_result["metrics"].get(
                "requirements_completion_rate", 0
            ),
        )

        if auto_send:

            client = session.exec(select(Client).where(Client.id == client_id)).first()

            if client and client.email:
                daily_report.recipient_email = client.email
                daily_report.email_delivery_status = "pending"

                send_email_task.delay(
                    to_email=client.email,
                    subject=f"Daily Progress Report - {report_result['project_id']} ({report_date})",
                    body=report_result["report_body_text"],
                    html_body=report_result["report_body_html"],
                )

                daily_report.email_sent = True
                daily_report.email_sent_at = datetime.now()
                daily_report.email_delivery_status = "sent"

                logger.info(f"Daily report email sent to {client.email}")

        session.add(daily_report)
        session.commit()
        session.refresh(daily_report)

        logger.info(f"Daily report saved successfully (ID: {daily_report.id})")

        return {
            "status": "success",
            "report_id": daily_report.id,
            "report_date": report_date,
            "email_sent": auto_send,
        }

    except Exception as e:
        logger.error(f"Error in daily report generation task: {str(e)}", exc_info=True)
        if self.request.retries < self.max_retries:
            raise self.retry(exc=e, countdown=60 * (2**self.request.retries))
        return {"status": "error", "message": str(e)}


@celery_app.task(bind=True, max_retries=2)
def generate_employee_daily_report(
    self, employee_id: int, auto_send: bool = True, report_date: str = None
):
    """
    Generate daily performance report for an employee using AI agent.
    This task should be scheduled to run daily for all active employees.

    Args:
        employee_id: Employee (User) ID
        auto_send: Whether to send report via email
        report_date: Date for the report (defaults to today)
    """
    from app.database.product_manager_models import EmployeeDailyReport
    from app.database.employee_models import User
    from sqlmodel import select

    try:
        logger.info(f"Starting employee report generation for employee {employee_id}")

        session = next(get_session())

        if not report_date:
            report_date = datetime.now().strftime("%Y-%m-%d")

        agent = EmployeePerformanceAgent(session)

        report_result = agent.generate_employee_report(
            employee_id=employee_id, report_date=report_date
        )

        if not report_result.get("success"):
            error_msg = report_result.get("error", "Unknown error")
            logger.error(f"Employee report generation failed: {error_msg}")
            raise self.retry(
                exc=Exception(error_msg), countdown=60 * (2**self.request.retries)
            )

        employee_report = EmployeeDailyReport(
            employee_id=employee_id,
            report_date=datetime.now(),
            generated_at=datetime.now(),
            trigger_type="scheduled",
            summary=report_result["summary"],
            achievements=str(report_result["achievements"]),
            challenges=str(report_result["challenges"]),
            recommendations=str(report_result["recommendations"]),
            focus_areas=str(report_result["focus_areas"]),
            report_body_text=report_result["report_body_text"],
            report_body_html=report_result["report_body_html"],
            tasks_completed_today=report_result["metrics"].get(
                "tasks_completed_today", 0
            ),
            tasks_in_progress=report_result["metrics"].get("tasks_in_progress", 0),
            projects_worked_on=report_result.get("projects_count", 0),
            overall_completion_rate=report_result["metrics"].get("completion_rate", 0),
            productivity_score=report_result["metrics"].get("productivity_score", 0),
            task_ids_included="",
        )

        if auto_send:

            employee = session.exec(select(User).where(User.id == employee_id)).first()

            if employee and employee.email:
                employee_report.recipient_email = employee.email
                employee_report.email_delivery_status = "pending"

                send_email_task.delay(
                    to_email=employee.email,
                    subject=f"Daily Performance Report - {employee.name} ({report_date})",
                    body=report_result["report_body_text"],
                    html_body=report_result["report_body_html"],
                )

                employee_report.email_sent = True
                employee_report.email_sent_at = datetime.now()
                employee_report.email_delivery_status = "sent"

                logger.info(f"Employee report email sent to {employee.email}")

        session.add(employee_report)
        session.commit()
        session.refresh(employee_report)

        logger.info(f"Employee report saved successfully (ID: {employee_report.id})")

        return {
            "status": "success",
            "report_id": employee_report.id,
            "report_date": report_date,
            "email_sent": auto_send,
        }

    except Exception as e:
        logger.error(
            f"Error in employee report generation task: {str(e)}", exc_info=True
        )
        if self.request.retries < self.max_retries:
            raise self.retry(exc=e, countdown=60 * (2**self.request.retries))
        return {"status": "error", "message": str(e)}
